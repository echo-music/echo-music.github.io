---
layout: post
title: go work 的用法
categories: grpc
description: go work 的用法
keywords: grpc,go,proto,protobuf
---

开发项目的时候，我们通常会有一个公共的仓库，比如lib-go。所有的开发组同学都会在自己负责的项目中去
引用需要的公共包。或者去lib-go修改公共包。

举个例子lib-go下有个pzip包

```
func Zip(files []File, target string) error{

}

```

那我去自己的项目比如A项目去使用的pzip包中Zip()方法，那就需要引入这个包（这个包下的所有文件之前已经提交）。

A项目中引入该包

```
import "github.com/echo-music/lib-go/pzip"

func main(){
       var files []File
       var target string
       pzip.Zip(files,target)
}
```
那这样调用没啥问题，如果后面我修改了Zip方法，此时我再次运行A项目main方法，和之前运行的结果一样，并没有打印修改后的结果！
那该怎么办呢。我这里有两种方法可以搞定：

```

1、先提交lib-go仓库，并把修改后的代码推送到远程仓库，然后到A项目中 
go get github.com/echo-music/lib-go/pzip@master

就会把lib-go最新的代码拉下来了，运行代码会打印修改后的结果。


2、在go.mod文件中通过 replace 指令，将旧的库地址，替换为新的库地址来实现这一操作。

replace (
	github.com/echo-music/lib-go/pzip latest => /usr/fangting/workspace/lib-go
)

这样不需要将lib-go代码提交到远程了，本地A项目就可以使用lib-go修改的方法了

```

好了，上面两种方式说完了，大家想想有什么弊端呢？


